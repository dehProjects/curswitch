ARM GAS  /tmp/ccWFqRSS.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"SerialTaskReceive.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.advancebuf,"ax",%progbits
  20              		.align	2
  21              		.thumb
  22              		.thumb_func
  24              	advancebuf:
  25              	.LFB73:
  26              		.file 1 "Ourwares/SerialTaskReceive.c"
   1:Ourwares/SerialTaskReceive.c **** /******************************************************************************
   2:Ourwares/SerialTaskReceive.c **** * File Name          : SerialTaskReceive.c
   3:Ourwares/SerialTaskReceive.c **** * Date First Issued  : 01/21/2019
   4:Ourwares/SerialTaskReceive.c **** * Description        : Serial input using FreeRTOS/ST HAL
   5:Ourwares/SerialTaskReceive.c **** *******************************************************************************/
   6:Ourwares/SerialTaskReceive.c **** 
   7:Ourwares/SerialTaskReceive.c **** #include "FreeRTOS.h"
   8:Ourwares/SerialTaskReceive.c **** #include "task.h"
   9:Ourwares/SerialTaskReceive.c **** #include "queue.h"
  10:Ourwares/SerialTaskReceive.c **** #include "cmsis_os.h"
  11:Ourwares/SerialTaskReceive.c **** #include "malloc.h"
  12:Ourwares/SerialTaskReceive.c **** #include "SerialTaskReceive.h"
  13:Ourwares/SerialTaskReceive.c **** #include "stm32f1xx_hal_usart.h"
  14:Ourwares/SerialTaskReceive.c **** #include "stm32f1xx_hal_uart.h"
  15:Ourwares/SerialTaskReceive.c **** #include "morse.h"
  16:Ourwares/SerialTaskReceive.c **** 
  17:Ourwares/SerialTaskReceive.c **** /* May not want all the gateway routines pulled in. */
  18:Ourwares/SerialTaskReceive.c **** #ifdef USECANMODEWITHGATEWAYROUTINES
  19:Ourwares/SerialTaskReceive.c ****  #include "gateway_PCtoCAN.h"
  20:Ourwares/SerialTaskReceive.c **** #endif
  21:Ourwares/SerialTaskReceive.c **** 
  22:Ourwares/SerialTaskReceive.c **** /*
  23:Ourwares/SerialTaskReceive.c **** BaseType_t Rret; // Return value
  24:Ourwares/SerialTaskReceive.c **** ...
  25:Ourwares/SerialTaskReceive.c **** // Initialization before schedular start
  26:Ourwares/SerialTaskReceive.c **** ...
  27:Ourwares/SerialTaskReceive.c **** // uart handle, and dma flag
  28:Ourwares/SerialTaskReceive.c **** Rret = xSerialTaskReceiveAdd(&huart6, 1);
  29:Ourwares/SerialTaskReceive.c **** if (Rret != 0) while(1==1); // Hang
  30:Ourwares/SerialTaskReceive.c **** ...
  31:Ourwares/SerialTaskReceive.c **** // Task initialization, before endless loop
  32:Ourwares/SerialTaskReceive.c **** ...
ARM GAS  /tmp/ccWFqRSS.s 			page 2


  33:Ourwares/SerialTaskReceive.c **** // uart handle, number line buffers, size of line buffers (not including \0)
  34:Ourwares/SerialTaskReceive.c **** #define NOTEBIT 0x1;	// Unique bit in this task for this buffer notification
  35:Ourwares/SerialTaskReceive.c **** uint32_t noteval = 0;	// OS copies its notification word upon a "notify"
  36:Ourwares/SerialTaskReceive.c **** // uart handle, dma flag, buffer notify bit, number line buffers, size of line buffers);
  37:Ourwares/SerialTaskReceive.c **** struct SERIALTASKRCVBCB* pinbuf1 = getserialinbuf(&huart6,1, NOTEBIT,&noteval,10,32); 
  38:Ourwares/SerialTaskReceive.c **** ...other getserialinbuf(...) if more than one...
  39:Ourwares/SerialTaskReceive.c **** 
  40:Ourwares/SerialTaskReceive.c **** ...
  41:Ourwares/SerialTaskReceive.c **** for ( ;; )
  42:Ourwares/SerialTaskReceive.c **** {
  43:Ourwares/SerialTaskReceive.c **** ...
  44:Ourwares/SerialTaskReceive.c **** yscanf(pinbuf1," ...",...);
  45:Ourwares/SerialTaskReceive.c **** ...
  46:Ourwares/SerialTaskReceive.c **** }
  47:Ourwares/SerialTaskReceive.c **** 
  48:Ourwares/SerialTaskReceive.c **** */
  49:Ourwares/SerialTaskReceive.c **** 
  50:Ourwares/SerialTaskReceive.c **** static void unloaddma(struct SERIALRCVBCB* prbcb);
  51:Ourwares/SerialTaskReceive.c **** 
  52:Ourwares/SerialTaskReceive.c **** osThreadId SerialTaskReceiveHandle = NULL;
  53:Ourwares/SerialTaskReceive.c **** 
  54:Ourwares/SerialTaskReceive.c **** /* THE FOLLOWING COPIED FOR REFERENCE--
  55:Ourwares/SerialTaskReceive.c **** // Line buffer control block for one uart 
  56:Ourwares/SerialTaskReceive.c **** struct SERIALRCVBCB
  57:Ourwares/SerialTaskReceive.c **** {
  58:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* pnext;	// Link to next uart RBCB
  59:Ourwares/SerialTaskReceive.c **** 	char* pbegin;// Ptr to first line buffer
  60:Ourwares/SerialTaskReceive.c **** 	char* pend;  // Ptr to last+1 line buffer
  61:Ourwares/SerialTaskReceive.c **** 	char* padd;  // Ptr to line buffer being filled
  62:Ourwares/SerialTaskReceive.c **** 	char* ptake; // Ptr to line buffer to take
  63:Ourwares/SerialTaskReceive.c **** 	char* pwork; // Ptr to next char to be added
  64:Ourwares/SerialTaskReceive.c **** 	char* pworkend; // Ptr to end of current active line buffer
  65:Ourwares/SerialTaskReceive.c **** 	UART_HandleTypeDef* phuart;// Pointer to 'MX uart handle
  66:Ourwares/SerialTaskReceive.c **** 	osThreadId tskhandle;      // Task handle of originating task
  67:Ourwares/SerialTaskReceive.c **** 	uint32_t  notebit;         // Unique notification bit (within task)
  68:Ourwares/SerialTaskReceive.c **** 	uint32_t* pnoteval;        // Pointer to word receiving notification 
  69:Ourwares/SerialTaskReceive.c **** 	char*  pbegindma;          // Pointer to beginning of dma buffer
  70:Ourwares/SerialTaskReceive.c **** 	char*  penddma;            // Pointer to ebd + 1 of dma buffer
  71:Ourwares/SerialTaskReceive.c **** 	char*  ptakedma;           // Pointer to last + 1 char taken from dma buffer
  72:Ourwares/SerialTaskReceive.c **** 	uint32_t  numlinexsize;    // Number of lines * line size (chars)
  73:Ourwares/SerialTaskReceive.c **** 	uint16_t  linesize;        // Number of chars in each line buffer (1)
  74:Ourwares/SerialTaskReceive.c **** 	uint16_t  dmasize;         // Number of chars in total circular DMA buffer
  75:Ourwares/SerialTaskReceive.c **** 	uint8_t   numline;         // Number of line (or CAN msg) buffers for this uart
  76:Ourwares/SerialTaskReceive.c **** 	int8_t    dmaflag;         // dmaflag = 0 for char-by-char mode; 1 = dma mode (1)
  77:Ourwares/SerialTaskReceive.c **** 	uint8_t   CANmode;         // 0 = ordinary lines; 1 = ascii/hex CAN
  78:Ourwares/SerialTaskReceive.c **** 	struct GATEWAYPCTOCAN* pgptc; // Pointer to gateway_PCtoCAN control block
  79:Ourwares/SerialTaskReceive.c **** 	uint32_t errorct;				// uart error callback counter
  80:Ourwares/SerialTaskReceive.c **** };
  81:Ourwares/SerialTaskReceive.c **** 
  82:Ourwares/SerialTaskReceive.c **** */
  83:Ourwares/SerialTaskReceive.c **** 
  84:Ourwares/SerialTaskReceive.c **** /* Pointer to linked list of Receive Buffer Control Blocks */
  85:Ourwares/SerialTaskReceive.c **** // Initial is NULL; pnext in last points to last
  86:Ourwares/SerialTaskReceive.c **** static struct SERIALRCVBCB* prbhd = NULL;
  87:Ourwares/SerialTaskReceive.c **** 
  88:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
  89:Ourwares/SerialTaskReceive.c ****  * struct SERIALRCVBCB* xSerialTaskRxAdduart(\
ARM GAS  /tmp/ccWFqRSS.s 			page 3


  90:Ourwares/SerialTaskReceive.c **** 		UART_HandleTypeDef* phuart,\
  91:Ourwares/SerialTaskReceive.c **** 		int8_t    dmaflag,\
  92:Ourwares/SerialTaskReceive.c **** 		uint32_t  notebit,\
  93:Ourwares/SerialTaskReceive.c **** 		uint32_t* pnoteval,\
  94:Ourwares/SerialTaskReceive.c **** 		uint8_t   numline,\
  95:Ourwares/SerialTaskReceive.c **** 		uint8_t   linesize,\
  96:Ourwares/SerialTaskReceive.c **** 		char  dmasize,\
  97:Ourwares/SerialTaskReceive.c **** 		uint8_t   CANmode);
  98:Ourwares/SerialTaskReceive.c ****  *	@brief	: Setup circular line buffers this uart
  99:Ourwares/SerialTaskReceive.c ****  * @param	: phuart = pointer to uart control block
 100:Ourwares/SerialTaskReceive.c ****  * @param	: dmaflag = 0 for char-by-char mode; 1 = dma mode
 101:Ourwares/SerialTaskReceive.c ****  * @param	: notebit = unique bit for notification for this task
 102:Ourwares/SerialTaskReceive.c ****  * @param	: pnoteval = pointer to word receiving notification word from OS
 103:Ourwares/SerialTaskReceive.c ****  * @param	: numline = number of line buffers in circular line buffer
 104:Ourwares/SerialTaskReceive.c ****  * @param	: linesize = number of chars in each line buffer
 105:Ourwares/SerialTaskReceive.c ****  * @param	: dmasize = number of chars in total circular DMA buffer
 106:Ourwares/SerialTaskReceive.c ****  * @param	: CANmode = 0 = straight ascii lines; 1 = convert ascii to CAN msgs
 107:Ourwares/SerialTaskReceive.c ****  * @return	: pointer = 'RCVBCB for this uart; NULL = failed
 108:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 109:Ourwares/SerialTaskReceive.c **** struct SERIALRCVBCB* xSerialTaskRxAdduart(\
 110:Ourwares/SerialTaskReceive.c **** 		UART_HandleTypeDef* phuart,\
 111:Ourwares/SerialTaskReceive.c **** 		int8_t    dmaflag, \
 112:Ourwares/SerialTaskReceive.c **** 		uint32_t  notebit, \
 113:Ourwares/SerialTaskReceive.c **** 		uint32_t* pnoteval,\
 114:Ourwares/SerialTaskReceive.c **** 		uint8_t   numline, \
 115:Ourwares/SerialTaskReceive.c **** 		uint8_t   linesize,\
 116:Ourwares/SerialTaskReceive.c **** 		char      dmasize, \
 117:Ourwares/SerialTaskReceive.c **** 		uint8_t   CANmode  )
 118:Ourwares/SerialTaskReceive.c **** {
 119:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* ptmp1;
 120:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* ptmp2;
 121:Ourwares/SerialTaskReceive.c **** 	char* pbuf;
 122:Ourwares/SerialTaskReceive.c **** 
 123:Ourwares/SerialTaskReceive.c **** HAL_StatusTypeDef halret;
 124:Ourwares/SerialTaskReceive.c **** 
 125:Ourwares/SerialTaskReceive.c **** #ifdef USECANMODEWITHGATEWAYROUTINES
 126:Ourwares/SerialTaskReceive.c **** 	struct GATEWAYPCTOCAN* pgptc; // Pointer to Gateway Pc To Can
 127:Ourwares/SerialTaskReceive.c **** #endif
 128:Ourwares/SerialTaskReceive.c **** 
 129:Ourwares/SerialTaskReceive.c **** 	/* There can be a problem with Tasks not started if the calling task gets here first */
 130:Ourwares/SerialTaskReceive.c **** 	osDelay(10);
 131:Ourwares/SerialTaskReceive.c **** 
 132:Ourwares/SerialTaskReceive.c **** taskENTER_CRITICAL();
 133:Ourwares/SerialTaskReceive.c **** 	/* Add block with circular buffer pointers for this uart/usart to list */
 134:Ourwares/SerialTaskReceive.c **** 	ptmp1 = (struct SERIALRCVBCB*)calloc(1, sizeof(struct SERIALRCVBCB));
 135:Ourwares/SerialTaskReceive.c **** 	if (ptmp1  == NULL) {taskEXIT_CRITICAL();morse_trap(60);}
 136:Ourwares/SerialTaskReceive.c **** 	if (prbhd  == NULL) // Is this the first?
 137:Ourwares/SerialTaskReceive.c **** 	{ // Yes.  
 138:Ourwares/SerialTaskReceive.c **** 		prbhd = ptmp1;	// Point head to first on list
 139:Ourwares/SerialTaskReceive.c **** 		ptmp1->pnext = ptmp1; // Point first (and last) item on list to self
 140:Ourwares/SerialTaskReceive.c **** 	}
 141:Ourwares/SerialTaskReceive.c **** 	else
 142:Ourwares/SerialTaskReceive.c **** 	{ // No. One or more have been added
 143:Ourwares/SerialTaskReceive.c **** 		/* Find end of list */
 144:Ourwares/SerialTaskReceive.c **** 		ptmp2 = prbhd;	// Start at head
 145:Ourwares/SerialTaskReceive.c **** 		while (ptmp2 != ptmp2->pnext) ptmp2 = ptmp2->pnext;
 146:Ourwares/SerialTaskReceive.c **** 		ptmp2->pnext = ptmp1; // Last block points to added block
ARM GAS  /tmp/ccWFqRSS.s 			page 4


 147:Ourwares/SerialTaskReceive.c **** 		ptmp1->pnext = ptmp1; // Added (and last) lock points to self
 148:Ourwares/SerialTaskReceive.c **** 	}
 149:Ourwares/SerialTaskReceive.c **** 
 150:Ourwares/SerialTaskReceive.c **** 	/* CAN msg conversion depends on line buffer size being large enough for CAN msg. */
 151:Ourwares/SerialTaskReceive.c **** 	if ((CANmode != 0) && (linesize < sizeof(struct CANRCVBUFPLUS))) 
 152:Ourwares/SerialTaskReceive.c **** 	     linesize = sizeof(struct CANRCVBUFPLUS);
 153:Ourwares/SerialTaskReceive.c **** 
 154:Ourwares/SerialTaskReceive.c **** 	/* Get memory for an array of line buffers for this uart */	
 155:Ourwares/SerialTaskReceive.c **** 	pbuf = (char*)calloc(numline*linesize, sizeof(char));
 156:Ourwares/SerialTaskReceive.c **** 	if ( pbuf == NULL) {taskEXIT_CRITICAL();morse_trap(61);}
 157:Ourwares/SerialTaskReceive.c **** 
 158:Ourwares/SerialTaskReceive.c **** 	/* Save parameters */
 159:Ourwares/SerialTaskReceive.c **** 	// ptmp1 points to last item on list
 160:Ourwares/SerialTaskReceive.c **** 	ptmp1->numlinexsize = numline*linesize;
 161:Ourwares/SerialTaskReceive.c **** 	ptmp1->linesize  = linesize;
 162:Ourwares/SerialTaskReceive.c **** 	ptmp1->numline   = numline;
 163:Ourwares/SerialTaskReceive.c **** 	ptmp1->dmaflag   = dmaflag;
 164:Ourwares/SerialTaskReceive.c **** 	ptmp1->pnoteval  = pnoteval;
 165:Ourwares/SerialTaskReceive.c **** 	ptmp1->notebit   = notebit;
 166:Ourwares/SerialTaskReceive.c **** 	ptmp1->phuart    = phuart;
 167:Ourwares/SerialTaskReceive.c **** 	ptmp1->tskhandle = xTaskGetCurrentTaskHandle();
 168:Ourwares/SerialTaskReceive.c **** 	ptmp1->errorct   = 0;
 169:Ourwares/SerialTaskReceive.c **** 
 170:Ourwares/SerialTaskReceive.c **** 	/* Initialize line buffer pointers */
 171:Ourwares/SerialTaskReceive.c **** 	ptmp1->pbegin = pbuf; // First line buffer beginning
 172:Ourwares/SerialTaskReceive.c **** 	ptmp1->padd   = pbuf; // Pointer to where next line will be added
 173:Ourwares/SerialTaskReceive.c **** 	ptmp1->ptake  = pbuf; // Pointer to where next line will be taken
 174:Ourwares/SerialTaskReceive.c **** 	ptmp1->pwork  = pbuf; // Pointer where next char in active line will be added
 175:Ourwares/SerialTaskReceive.c **** 	ptmp1->pworkend = pbuf + linesize - 2; // End of 1st LINE buffer (allow for zero terminator)
 176:Ourwares/SerialTaskReceive.c **** 	ptmp1->pend = pbuf + numline*linesize; // End of line buffers + 1 line
 177:Ourwares/SerialTaskReceive.c **** 	ptmp1->CANmode = CANmode;
 178:Ourwares/SerialTaskReceive.c **** 
 179:Ourwares/SerialTaskReceive.c **** 	if (dmaflag != 0)
 180:Ourwares/SerialTaskReceive.c **** 	{ // Circular DMA buffer 
 181:Ourwares/SerialTaskReceive.c **** 		pbuf = (char*)calloc((int)dmasize, sizeof(char));
 182:Ourwares/SerialTaskReceive.c **** 		if ( pbuf == NULL) morse_trap(62);
 183:Ourwares/SerialTaskReceive.c **** 		ptmp1->pbegindma = pbuf;   // Pointer to beginning of DMA circular buffer
 184:Ourwares/SerialTaskReceive.c **** 		ptmp1->penddma   = pbuf + dmasize; // Pointer to end + 1
 185:Ourwares/SerialTaskReceive.c **** 		ptmp1->ptakedma  = pbuf;   // "Take" Pointer into DMA buffer
 186:Ourwares/SerialTaskReceive.c **** 		ptmp1->dmasize   = dmasize; // Total number of chars in DMA buffer
 187:Ourwares/SerialTaskReceive.c **** 
 188:Ourwares/SerialTaskReceive.c **** #ifdef USECANMODEWITHGATEWAYROUTINES
 189:Ourwares/SerialTaskReceive.c **** 		/* When CANmode is requested, the conversion control block is used */
 190:Ourwares/SerialTaskReceive.c **** 		if (CANmode == 1)
 191:Ourwares/SerialTaskReceive.c **** 		{ // Initialize CAN conversion control block
 192:Ourwares/SerialTaskReceive.c **** 			pgptc = gateway_PCtoCAN_init(ptmp1);
 193:Ourwares/SerialTaskReceive.c **** 			if (pgptc == NULL)  {taskEXIT_CRITICAL();morse_trap(63);}
 194:Ourwares/SerialTaskReceive.c **** 			ptmp1->pgptc = pgptc; // Save pointer to CAN conversion control block
 195:Ourwares/SerialTaskReceive.c **** 		}
 196:Ourwares/SerialTaskReceive.c **** #endif
 197:Ourwares/SerialTaskReceive.c **** 
 198:Ourwares/SerialTaskReceive.c **** 		/* Start uart-dma circular mode.  Start once; run forever. */
 199:Ourwares/SerialTaskReceive.c **** 		halret = HAL_UART_Receive_DMA(ptmp1->phuart, (uint8_t*)ptmp1->pbegindma, ptmp1->dmasize);
 200:Ourwares/SerialTaskReceive.c **** 		if (halret == HAL_ERROR)
 201:Ourwares/SerialTaskReceive.c **** 		{
 202:Ourwares/SerialTaskReceive.c **** 			taskEXIT_CRITICAL();
 203:Ourwares/SerialTaskReceive.c **** 			morse_trap(64);
ARM GAS  /tmp/ccWFqRSS.s 			page 5


 204:Ourwares/SerialTaskReceive.c **** //			return NULL;
 205:Ourwares/SerialTaskReceive.c **** 		}
 206:Ourwares/SerialTaskReceive.c **** 	}
 207:Ourwares/SerialTaskReceive.c **** 	else
 208:Ourwares/SerialTaskReceive.c **** 	{ // Start char-by-char mode. Restart upon each interrupt.
 209:Ourwares/SerialTaskReceive.c **** 		halret = HAL_UART_Receive_IT(ptmp1->phuart, (uint8_t*)ptmp1->pwork, 1);
 210:Ourwares/SerialTaskReceive.c **** 		if (halret == HAL_ERROR)
 211:Ourwares/SerialTaskReceive.c **** 		{
 212:Ourwares/SerialTaskReceive.c **** 			taskEXIT_CRITICAL();
 213:Ourwares/SerialTaskReceive.c **** 			morse_trap(65);
 214:Ourwares/SerialTaskReceive.c **** //			return NULL;
 215:Ourwares/SerialTaskReceive.c **** 		}
 216:Ourwares/SerialTaskReceive.c **** 	}
 217:Ourwares/SerialTaskReceive.c **** taskEXIT_CRITICAL();
 218:Ourwares/SerialTaskReceive.c **** 	return ptmp1;	// Success return pointer to this 'BCB
 219:Ourwares/SerialTaskReceive.c **** }
 220:Ourwares/SerialTaskReceive.c **** 
 221:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 222:Ourwares/SerialTaskReceive.c ****  * void StartSerialTaskReceive(void* argument);
 223:Ourwares/SerialTaskReceive.c ****  *	@brief	: Task startup
 224:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 225:Ourwares/SerialTaskReceive.c **** void StartSerialTaskReceive(void* argument)
 226:Ourwares/SerialTaskReceive.c **** {
 227:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* prtmp = prbhd;
 228:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* prtmp2;
 229:Ourwares/SerialTaskReceive.c **** 	
 230:Ourwares/SerialTaskReceive.c **** 	/* Do nothing until at least one tasks calls 
 231:Ourwares/SerialTaskReceive.c ****       'xSerialTaskRxAdduart' and sets up the 
 232:Ourwares/SerialTaskReceive.c ****        uart and buffering. */
 233:Ourwares/SerialTaskReceive.c **** 
 234:Ourwares/SerialTaskReceive.c **** 	while (prtmp == NULL)
 235:Ourwares/SerialTaskReceive.c **** 	{
 236:Ourwares/SerialTaskReceive.c **** 		osDelay(10);
 237:Ourwares/SerialTaskReceive.c **** 		prtmp = prbhd;
 238:Ourwares/SerialTaskReceive.c **** 	}
 239:Ourwares/SerialTaskReceive.c **** 
 240:Ourwares/SerialTaskReceive.c ****   /* Infinite loop */
 241:Ourwares/SerialTaskReceive.c ****   for(;;)
 242:Ourwares/SerialTaskReceive.c ****   {
 243:Ourwares/SerialTaskReceive.c **** 		/* Wait for one tick or notification from a dma callback */
 244:Ourwares/SerialTaskReceive.c **** 		xTaskNotifyWait(0, 0, NULL, 2);
 245:Ourwares/SerialTaskReceive.c **** 
 246:Ourwares/SerialTaskReceive.c **** 		/* Go through list of receiving uarts and unload only dma uart buffers. */
 247:Ourwares/SerialTaskReceive.c **** 		prtmp = prbhd;
 248:Ourwares/SerialTaskReceive.c **** 		do
 249:Ourwares/SerialTaskReceive.c **** 		{
 250:Ourwares/SerialTaskReceive.c **** 			if (prtmp->dmaflag != 0)
 251:Ourwares/SerialTaskReceive.c **** 			{ // Here, dma mode
 252:Ourwares/SerialTaskReceive.c **** 				if (prtmp->CANmode == 1)
 253:Ourwares/SerialTaskReceive.c **** 				{ // Here, convert to CAN msg buffers
 254:Ourwares/SerialTaskReceive.c **** #ifdef USECANMODEWITHGATEWAYROUTINES
 255:Ourwares/SerialTaskReceive.c **** 					gateway_PCtoCAN_unloaddma(prtmp);
 256:Ourwares/SerialTaskReceive.c **** #endif
 257:Ourwares/SerialTaskReceive.c **** 				}
 258:Ourwares/SerialTaskReceive.c **** 				else
 259:Ourwares/SerialTaskReceive.c **** 				{ // Here, straight ascii line buffers
 260:Ourwares/SerialTaskReceive.c **** 					unloaddma(prtmp);
ARM GAS  /tmp/ccWFqRSS.s 			page 6


 261:Ourwares/SerialTaskReceive.c **** 				}
 262:Ourwares/SerialTaskReceive.c **** 			}
 263:Ourwares/SerialTaskReceive.c **** 			prtmp2 = prtmp;
 264:Ourwares/SerialTaskReceive.c **** 			prtmp = prtmp2->pnext;
 265:Ourwares/SerialTaskReceive.c **** 		} while (prtmp2->pnext != prtmp2);
 266:Ourwares/SerialTaskReceive.c ****   }
 267:Ourwares/SerialTaskReceive.c **** }
 268:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 269:Ourwares/SerialTaskReceive.c ****  * osThreadId xSerialTaskReceiveCreate(uint32_t taskpriority);
 270:Ourwares/SerialTaskReceive.c ****  * @brief	: Create task; task handle created is global for all to enjoy!
 271:Ourwares/SerialTaskReceive.c ****  * @param	: taskpriority = Task priority (just as it says!)
 272:Ourwares/SerialTaskReceive.c ****  * @return	: SerialTaskReceiveHandle
 273:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 274:Ourwares/SerialTaskReceive.c ****  osThreadId xSerialTaskReceiveCreate(uint32_t taskpriority)
 275:Ourwares/SerialTaskReceive.c **** {
 276:Ourwares/SerialTaskReceive.c **** /*
 277:Ourwares/SerialTaskReceive.c **** BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,
 278:Ourwares/SerialTaskReceive.c **** const char * const pcName,
 279:Ourwares/SerialTaskReceive.c **** unsigned short usStackDepth,
 280:Ourwares/SerialTaskReceive.c **** void *pvParameters,
 281:Ourwares/SerialTaskReceive.c **** UBaseType_t uxPriority,
 282:Ourwares/SerialTaskReceive.c **** TaskHandle_t *pxCreatedTask );
 283:Ourwares/SerialTaskReceive.c **** */
 284:Ourwares/SerialTaskReceive.c **** 	BaseType_t ret = xTaskCreate(StartSerialTaskReceive, "StartSerialTaskReceive",\
 285:Ourwares/SerialTaskReceive.c ****         96, NULL, taskpriority, &SerialTaskReceiveHandle);
 286:Ourwares/SerialTaskReceive.c **** 	if (ret != pdPASS) return NULL;
 287:Ourwares/SerialTaskReceive.c **** 	return SerialTaskReceiveHandle;
 288:Ourwares/SerialTaskReceive.c **** }
 289:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 290:Ourwares/SerialTaskReceive.c ****  * char* xSerialTaskReceiveGetline(struct SERIALRCVBCB* pbcb);
 291:Ourwares/SerialTaskReceive.c ****  *	@brief	: Load buffer control block onto queue for sending
 292:Ourwares/SerialTaskReceive.c ****  * @param	: pbcb = Pointer to Buffer Control Block
 293:Ourwares/SerialTaskReceive.c ****  * @return	: Pointer to line buffer; NULL = no new lines
 294:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 295:Ourwares/SerialTaskReceive.c **** char* xSerialTaskReceiveGetline(struct SERIALRCVBCB* pbcb)
 296:Ourwares/SerialTaskReceive.c **** {
 297:Ourwares/SerialTaskReceive.c **** 	char* p = NULL;
 298:Ourwares/SerialTaskReceive.c **** 
 299:Ourwares/SerialTaskReceive.c **** 	/* Check no new lines. */
 300:Ourwares/SerialTaskReceive.c **** 	if (pbcb->ptake == pbcb->padd) return p;
 301:Ourwares/SerialTaskReceive.c **** 	p = pbcb->ptake;
 302:Ourwares/SerialTaskReceive.c **** 
 303:Ourwares/SerialTaskReceive.c **** 	/* Advance 'take' pointer w wraparound check. */
 304:Ourwares/SerialTaskReceive.c **** 	pbcb->ptake += pbcb->linesize;
 305:Ourwares/SerialTaskReceive.c **** 	if (pbcb->ptake >= pbcb->pend) pbcb->ptake = pbcb->pbegin;
 306:Ourwares/SerialTaskReceive.c **** 
 307:Ourwares/SerialTaskReceive.c **** 	return p;
 308:Ourwares/SerialTaskReceive.c **** }
 309:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 310:Ourwares/SerialTaskReceive.c ****  * static void advancebuf(struct SERIALRCVBCB* prtmp);
 311:Ourwares/SerialTaskReceive.c ****  * @brief	: Advance to next line buffer
 312:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 313:Ourwares/SerialTaskReceive.c **** static void advancebuf(struct SERIALRCVBCB* prtmp)
 314:Ourwares/SerialTaskReceive.c **** {		
  27              		.loc 1 314 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/ccWFqRSS.s 			page 7


  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 00B5     		push	{lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 4
  35              		.cfi_offset 14, -4
  36 0002 85B0     		sub	sp, sp, #20
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 24
 315:Ourwares/SerialTaskReceive.c **** 	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  39              		.loc 1 315 0
  40 0004 0023     		movs	r3, #0
  41 0006 0393     		str	r3, [sp, #12]
 316:Ourwares/SerialTaskReceive.c **** 
 317:Ourwares/SerialTaskReceive.c **** 	/* Zero terminator addition. */
 318:Ourwares/SerialTaskReceive.c **** 	*prtmp->pwork = 0; // Add string terminator
  42              		.loc 1 318 0
  43 0008 4269     		ldr	r2, [r0, #20]
  44 000a 1370     		strb	r3, [r2]
 319:Ourwares/SerialTaskReceive.c **** 	
 320:Ourwares/SerialTaskReceive.c **** 	/* Advance to beginning of next line buffer */
 321:Ourwares/SerialTaskReceive.c **** 	prtmp->padd += prtmp->linesize;	// Step ahead one buffer length
  45              		.loc 1 321 0
  46 000c 838F     		ldrh	r3, [r0, #60]
  47 000e C268     		ldr	r2, [r0, #12]
  48 0010 1A44     		add	r2, r2, r3
  49 0012 C260     		str	r2, [r0, #12]
 322:Ourwares/SerialTaskReceive.c **** 	if (prtmp->padd == prtmp->pend) prtmp->padd = prtmp->pbegin;
  50              		.loc 1 322 0
  51 0014 8168     		ldr	r1, [r0, #8]
  52 0016 8A42     		cmp	r2, r1
  53 0018 01D1     		bne	.L2
  54              		.loc 1 322 0 is_stmt 0 discriminator 1
  55 001a 4268     		ldr	r2, [r0, #4]
  56 001c C260     		str	r2, [r0, #12]
  57              	.L2:
 323:Ourwares/SerialTaskReceive.c **** 
 324:Ourwares/SerialTaskReceive.c **** 	/* Initialize working char pointers */
 325:Ourwares/SerialTaskReceive.c **** 	prtmp->pwork = prtmp->padd;	// Begin
  58              		.loc 1 325 0 is_stmt 1
  59 001e C268     		ldr	r2, [r0, #12]
  60 0020 4261     		str	r2, [r0, #20]
 326:Ourwares/SerialTaskReceive.c **** 	prtmp->pworkend = prtmp->padd + prtmp->linesize - 2; // End
  61              		.loc 1 326 0
  62 0022 023B     		subs	r3, r3, #2
  63 0024 1344     		add	r3, r3, r2
  64 0026 8361     		str	r3, [r0, #24]
 327:Ourwares/SerialTaskReceive.c **** 
 328:Ourwares/SerialTaskReceive.c **** 	/* Notify originating task know a line is ready. */
 329:Ourwares/SerialTaskReceive.c **** 	xTaskNotifyFromISR(prtmp->tskhandle, 
  65              		.loc 1 329 0
  66 0028 416A     		ldr	r1, [r0, #36]
  67 002a 006A     		ldr	r0, [r0, #32]
  68              	.LVL1:
  69 002c 03AB     		add	r3, sp, #12
  70 002e 0093     		str	r3, [sp]
  71 0030 0023     		movs	r3, #0
ARM GAS  /tmp/ccWFqRSS.s 			page 8


  72 0032 0122     		movs	r2, #1
  73 0034 FFF7FEFF 		bl	xTaskGenericNotifyFromISR
  74              	.LVL2:
 330:Ourwares/SerialTaskReceive.c **** 		prtmp->notebit,	/* 'or' bit assigned to buffer to notification value. */
 331:Ourwares/SerialTaskReceive.c **** 		eSetBits,      /* Set 'or' option */
 332:Ourwares/SerialTaskReceive.c **** 		&xHigherPriorityTaskWoken );
 333:Ourwares/SerialTaskReceive.c **** 
 334:Ourwares/SerialTaskReceive.c **** 	portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
  75              		.loc 1 334 0
  76 0038 039B     		ldr	r3, [sp, #12]
  77 003a 3BB1     		cbz	r3, .L1
  78              		.loc 1 334 0 is_stmt 0 discriminator 1
  79 003c 4FF08052 		mov	r2, #268435456
  80 0040 044B     		ldr	r3, .L5
  81 0042 1A60     		str	r2, [r3]
  82              		.syntax unified
  83              	@ 334 "Ourwares/SerialTaskReceive.c" 1
  84 0044 BFF34F8F 		dsb
  85              	@ 0 "" 2
  86              	@ 334 "Ourwares/SerialTaskReceive.c" 1
  87 0048 BFF36F8F 		isb
  88              	@ 0 "" 2
  89              		.thumb
  90              		.syntax unified
  91              	.L1:
 335:Ourwares/SerialTaskReceive.c **** 	return;
 336:Ourwares/SerialTaskReceive.c **** }
  92              		.loc 1 336 0 is_stmt 1
  93 004c 05B0     		add	sp, sp, #20
  94              	.LCFI2:
  95              		.cfi_def_cfa_offset 4
  96              		@ sp needed
  97 004e 5DF804FB 		ldr	pc, [sp], #4
  98              	.L6:
  99 0052 00BF     		.align	2
 100              	.L5:
 101 0054 04ED00E0 		.word	-536810236
 102              		.cfi_endproc
 103              	.LFE73:
 105              		.section	.text.advanceptr,"ax",%progbits
 106              		.align	2
 107              		.thumb
 108              		.thumb_func
 110              	advanceptr:
 111              	.LFB74:
 337:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 338:Ourwares/SerialTaskReceive.c ****  * static void advanceptr(struct SERIALRCVBCB* prtmp);
 339:Ourwares/SerialTaskReceive.c ****  * @brief	: Advance pointer within the active line buffer
 340:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 341:Ourwares/SerialTaskReceive.c **** static void advanceptr(struct SERIALRCVBCB* prtmp, char c)
 342:Ourwares/SerialTaskReceive.c **** {
 112              		.loc 1 342 0
 113              		.cfi_startproc
 114              		@ args = 0, pretend = 0, frame = 0
 115              		@ frame_needed = 0, uses_anonymous_args = 0
 116              	.LVL3:
 117 0000 08B5     		push	{r3, lr}
ARM GAS  /tmp/ccWFqRSS.s 			page 9


 118              	.LCFI3:
 119              		.cfi_def_cfa_offset 8
 120              		.cfi_offset 3, -8
 121              		.cfi_offset 14, -4
 343:Ourwares/SerialTaskReceive.c **** 	*prtmp->pwork++ = c;
 122              		.loc 1 343 0
 123 0002 4369     		ldr	r3, [r0, #20]
 124 0004 5A1C     		adds	r2, r3, #1
 125 0006 4261     		str	r2, [r0, #20]
 126 0008 1970     		strb	r1, [r3]
 344:Ourwares/SerialTaskReceive.c **** 	if (c == LINETERMINATOR) // || (c == 0XD))
 127              		.loc 1 344 0
 128 000a 0A29     		cmp	r1, #10
 129 000c 02D1     		bne	.L8
 345:Ourwares/SerialTaskReceive.c **** 	{ // Here End of Line
 346:Ourwares/SerialTaskReceive.c **** 		advancebuf(prtmp); // Advance to new line buffer and notify originator
 130              		.loc 1 346 0
 131 000e FFF7FEFF 		bl	advancebuf
 132              	.LVL4:
 347:Ourwares/SerialTaskReceive.c **** 		return;
 133              		.loc 1 347 0
 134 0012 08BD     		pop	{r3, pc}
 135              	.LVL5:
 136              	.L8:
 348:Ourwares/SerialTaskReceive.c **** 	}
 349:Ourwares/SerialTaskReceive.c **** 
 350:Ourwares/SerialTaskReceive.c **** 	/* Here, just an ordinary char stored. */
 351:Ourwares/SerialTaskReceive.c **** 	if (prtmp->pwork == prtmp->pworkend)
 137              		.loc 1 351 0
 138 0014 4269     		ldr	r2, [r0, #20]
 139 0016 8369     		ldr	r3, [r0, #24]
 140 0018 9A42     		cmp	r2, r3
 141 001a 01D1     		bne	.L7
 352:Ourwares/SerialTaskReceive.c **** 	{ // Here we are at end - 1 of line buffer
 353:Ourwares/SerialTaskReceive.c **** 		advancebuf(prtmp); // Advance to new line buffer and notify originator
 142              		.loc 1 353 0
 143 001c FFF7FEFF 		bl	advancebuf
 144              	.LVL6:
 145              	.L7:
 146 0020 08BD     		pop	{r3, pc}
 147              		.cfi_endproc
 148              	.LFE74:
 150 0022 00BF     		.section	.text.unloaddma,"ax",%progbits
 151              		.align	2
 152              		.thumb
 153              		.thumb_func
 155              	unloaddma:
 156              	.LFB75:
 354:Ourwares/SerialTaskReceive.c **** 	}	
 355:Ourwares/SerialTaskReceive.c **** 	return;
 356:Ourwares/SerialTaskReceive.c **** }
 357:Ourwares/SerialTaskReceive.c **** 
 358:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 359:Ourwares/SerialTaskReceive.c ****  * static void unloaddma(struct SERIALRCVBCB* prbcb);
 360:Ourwares/SerialTaskReceive.c ****  * @brief	: DMA: Check for line terminator and store; enter from task poll
 361:Ourwares/SerialTaskReceive.c ****  * @param	: prbcb = pointer to buffer control block for uart causing callback
 362:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
ARM GAS  /tmp/ccWFqRSS.s 			page 10


 363:Ourwares/SerialTaskReceive.c **** static void unloaddma(struct SERIALRCVBCB* prbcb)
 364:Ourwares/SerialTaskReceive.c **** {
 157              		.loc 1 364 0
 158              		.cfi_startproc
 159              		@ args = 0, pretend = 0, frame = 0
 160              		@ frame_needed = 0, uses_anonymous_args = 0
 161              	.LVL7:
 162 0000 38B5     		push	{r3, r4, r5, lr}
 163              	.LCFI4:
 164              		.cfi_def_cfa_offset 16
 165              		.cfi_offset 3, -16
 166              		.cfi_offset 4, -12
 167              		.cfi_offset 5, -8
 168              		.cfi_offset 14, -4
 169 0002 0446     		mov	r4, r0
 365:Ourwares/SerialTaskReceive.c **** 	uint16_t dmandtr;	// Number of data items remaining in DMA NDTR register
 366:Ourwares/SerialTaskReceive.c **** 	int32_t diff;
 367:Ourwares/SerialTaskReceive.c **** 	char c;
 368:Ourwares/SerialTaskReceive.c **** 
 369:Ourwares/SerialTaskReceive.c **** // bsp_uart.c handling of dma
 370:Ourwares/SerialTaskReceive.c **** //		Diff = ( pctl->rxbuff_end - DMA_SNDTR(pctl->idma,pctl->rxdma_stream) - pctl->rxbuff_out );
 371:Ourwares/SerialTaskReceive.c **** //		if (Diff < 0)
 372:Ourwares/SerialTaskReceive.c **** //			Diff += pctl->rxbuff_size;  // Adjust for wrap
 373:Ourwares/SerialTaskReceive.c **** 
 374:Ourwares/SerialTaskReceive.c **** 		/* Get number of data item count in DMA buffer "now" from DMA NDTR register. */
 375:Ourwares/SerialTaskReceive.c **** 		dmandtr = __HAL_DMA_GET_COUNTER(prbcb->phuart->hdmarx); 
 170              		.loc 1 375 0
 171 0004 C369     		ldr	r3, [r0, #28]
 172 0006 5B6B     		ldr	r3, [r3, #52]
 173 0008 1B68     		ldr	r3, [r3]
 174 000a 5D68     		ldr	r5, [r3, #4]
 175              	.LVL8:
 376:Ourwares/SerialTaskReceive.c **** 
 377:Ourwares/SerialTaskReceive.c **** 		/* Difference between where we are taking out chars, and where DMA is or was storing. */
 378:Ourwares/SerialTaskReceive.c **** 		diff = prbcb->penddma - dmandtr - prbcb->ptakedma; 
 176              		.loc 1 378 0
 177 000c 026B     		ldr	r2, [r0, #48]
 178 000e ADB2     		uxth	r5, r5
 179 0010 531B     		subs	r3, r2, r5
 180 0012 456B     		ldr	r5, [r0, #52]
 181              	.LVL9:
 379:Ourwares/SerialTaskReceive.c **** 		if (diff < 0)
 182              		.loc 1 379 0
 183 0014 5D1B     		subs	r5, r3, r5
 184              	.LVL10:
 185 0016 0FD5     		bpl	.L13
 380:Ourwares/SerialTaskReceive.c **** 		{ // Wrap around
 381:Ourwares/SerialTaskReceive.c **** 			diff += prbcb->dmasize;
 186              		.loc 1 381 0
 187 0018 C38F     		ldrh	r3, [r0, #62]
 188 001a 1D44     		add	r5, r5, r3
 189              	.LVL11:
 190 001c 0CE0     		b	.L13
 191              	.LVL12:
 192              	.L15:
 382:Ourwares/SerialTaskReceive.c **** 		}
 383:Ourwares/SerialTaskReceive.c **** 
ARM GAS  /tmp/ccWFqRSS.s 			page 11


 384:Ourwares/SerialTaskReceive.c **** 		/* Copy dma circular buffer into buffered lines */
 385:Ourwares/SerialTaskReceive.c **** 		while (diff > 0)
 386:Ourwares/SerialTaskReceive.c **** 		{
 387:Ourwares/SerialTaskReceive.c **** 			diff -= 1;
 193              		.loc 1 387 0
 194 001e 013D     		subs	r5, r5, #1
 195              	.LVL13:
 388:Ourwares/SerialTaskReceive.c **** 			c = *prbcb->ptakedma++; // Get char from dma buffer
 196              		.loc 1 388 0
 197 0020 626B     		ldr	r2, [r4, #52]
 198 0022 531C     		adds	r3, r2, #1
 199 0024 6363     		str	r3, [r4, #52]
 200 0026 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
 201              	.LVL14:
 389:Ourwares/SerialTaskReceive.c **** 			if (prbcb->ptakedma == prbcb->penddma) prbcb->ptakedma = prbcb->pbegindma;
 202              		.loc 1 389 0
 203 0028 226B     		ldr	r2, [r4, #48]
 204 002a 9342     		cmp	r3, r2
 205 002c 01D1     		bne	.L14
 206              		.loc 1 389 0 is_stmt 0 discriminator 1
 207 002e E36A     		ldr	r3, [r4, #44]
 208 0030 6363     		str	r3, [r4, #52]
 209              	.L14:
 390:Ourwares/SerialTaskReceive.c **** 			
 391:Ourwares/SerialTaskReceive.c **** 			advanceptr(prbcb,c);
 210              		.loc 1 391 0 is_stmt 1
 211 0032 2046     		mov	r0, r4
 212 0034 FFF7FEFF 		bl	advanceptr
 213              	.LVL15:
 214              	.L13:
 385:Ourwares/SerialTaskReceive.c **** 		{
 215              		.loc 1 385 0
 216 0038 002D     		cmp	r5, #0
 217 003a F0DC     		bgt	.L15
 392:Ourwares/SerialTaskReceive.c **** 		}
 393:Ourwares/SerialTaskReceive.c **** 		return;
 394:Ourwares/SerialTaskReceive.c **** }
 218              		.loc 1 394 0
 219 003c 38BD     		pop	{r3, r4, r5, pc}
 220              		.cfi_endproc
 221              	.LFE75:
 223 003e 00BF     		.section	.text.StartSerialTaskReceive,"ax",%progbits
 224              		.align	2
 225              		.global	StartSerialTaskReceive
 226              		.thumb
 227              		.thumb_func
 229              	StartSerialTaskReceive:
 230              	.LFB70:
 226:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* prtmp = prbhd;
 231              		.loc 1 226 0
 232              		.cfi_startproc
 233              		@ args = 0, pretend = 0, frame = 0
 234              		@ frame_needed = 0, uses_anonymous_args = 0
 235              	.LVL16:
 236 0000 10B5     		push	{r4, lr}
 237              	.LCFI5:
 238              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccWFqRSS.s 			page 12


 239              		.cfi_offset 4, -8
 240              		.cfi_offset 14, -4
 227:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* prtmp2;
 241              		.loc 1 227 0
 242 0002 114B     		ldr	r3, .L25
 243 0004 1B68     		ldr	r3, [r3]
 244              	.LVL17:
 234:Ourwares/SerialTaskReceive.c **** 	{
 245              		.loc 1 234 0
 246 0006 04E0     		b	.L18
 247              	.LVL18:
 248              	.L19:
 236:Ourwares/SerialTaskReceive.c **** 		prtmp = prbhd;
 249              		.loc 1 236 0
 250 0008 0A20     		movs	r0, #10
 251 000a FFF7FEFF 		bl	osDelay
 252              	.LVL19:
 237:Ourwares/SerialTaskReceive.c **** 	}
 253              		.loc 1 237 0
 254 000e 0E4B     		ldr	r3, .L25
 255 0010 1B68     		ldr	r3, [r3]
 256              	.LVL20:
 257              	.L18:
 234:Ourwares/SerialTaskReceive.c **** 	{
 258              		.loc 1 234 0
 259 0012 002B     		cmp	r3, #0
 260 0014 F8D0     		beq	.L19
 261              	.L22:
 244:Ourwares/SerialTaskReceive.c **** 
 262              		.loc 1 244 0
 263 0016 0223     		movs	r3, #2
 264              	.LVL21:
 265 0018 0022     		movs	r2, #0
 266 001a 1146     		mov	r1, r2
 267 001c 1046     		mov	r0, r2
 268 001e FFF7FEFF 		bl	xTaskNotifyWait
 269              	.LVL22:
 247:Ourwares/SerialTaskReceive.c **** 		do
 270              		.loc 1 247 0
 271 0022 094B     		ldr	r3, .L25
 272 0024 1C68     		ldr	r4, [r3]
 273              	.LVL23:
 274 0026 00E0     		b	.L21
 275              	.LVL24:
 276              	.L23:
 264:Ourwares/SerialTaskReceive.c **** 		} while (prtmp2->pnext != prtmp2);
 277              		.loc 1 264 0
 278 0028 1C46     		mov	r4, r3
 279              	.LVL25:
 280              	.L21:
 250:Ourwares/SerialTaskReceive.c **** 			{ // Here, dma mode
 281              		.loc 1 250 0
 282 002a 94F94130 		ldrsb	r3, [r4, #65]
 283 002e 33B1     		cbz	r3, .L20
 252:Ourwares/SerialTaskReceive.c **** 				{ // Here, convert to CAN msg buffers
 284              		.loc 1 252 0
 285 0030 94F84230 		ldrb	r3, [r4, #66]	@ zero_extendqisi2
ARM GAS  /tmp/ccWFqRSS.s 			page 13


 286 0034 012B     		cmp	r3, #1
 287 0036 02D0     		beq	.L20
 260:Ourwares/SerialTaskReceive.c **** 				}
 288              		.loc 1 260 0
 289 0038 2046     		mov	r0, r4
 290 003a FFF7FEFF 		bl	unloaddma
 291              	.LVL26:
 292              	.L20:
 264:Ourwares/SerialTaskReceive.c **** 		} while (prtmp2->pnext != prtmp2);
 293              		.loc 1 264 0
 294 003e 2368     		ldr	r3, [r4]
 295              	.LVL27:
 265:Ourwares/SerialTaskReceive.c ****   }
 296              		.loc 1 265 0
 297 0040 9C42     		cmp	r4, r3
 298 0042 F1D1     		bne	.L23
 299 0044 E7E7     		b	.L22
 300              	.L26:
 301 0046 00BF     		.align	2
 302              	.L25:
 303 0048 00000000 		.word	.LANCHOR0
 304              		.cfi_endproc
 305              	.LFE70:
 307              		.section	.text.xSerialTaskRxAdduart,"ax",%progbits
 308              		.align	2
 309              		.global	xSerialTaskRxAdduart
 310              		.thumb
 311              		.thumb_func
 313              	xSerialTaskRxAdduart:
 314              	.LFB69:
 118:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* ptmp1;
 315              		.loc 1 118 0
 316              		.cfi_startproc
 317              		@ args = 16, pretend = 0, frame = 16
 318              		@ frame_needed = 0, uses_anonymous_args = 0
 319              	.LVL28:
 320 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 321              	.LCFI6:
 322              		.cfi_def_cfa_offset 36
 323              		.cfi_offset 4, -36
 324              		.cfi_offset 5, -32
 325              		.cfi_offset 6, -28
 326              		.cfi_offset 7, -24
 327              		.cfi_offset 8, -20
 328              		.cfi_offset 9, -16
 329              		.cfi_offset 10, -12
 330              		.cfi_offset 11, -8
 331              		.cfi_offset 14, -4
 332 0004 85B0     		sub	sp, sp, #20
 333              	.LCFI7:
 334              		.cfi_def_cfa_offset 56
 335 0006 0190     		str	r0, [sp, #4]
 336 0008 8946     		mov	r9, r1
 337 000a 0292     		str	r2, [sp, #8]
 338 000c 0393     		str	r3, [sp, #12]
 339 000e 9DF838B0 		ldrb	fp, [sp, #56]	@ zero_extendqisi2
 340 0012 9DF83C50 		ldrb	r5, [sp, #60]	@ zero_extendqisi2
ARM GAS  /tmp/ccWFqRSS.s 			page 14


 341 0016 9DF84080 		ldrb	r8, [sp, #64]	@ zero_extendqisi2
 342 001a 9DF844A0 		ldrb	r10, [sp, #68]	@ zero_extendqisi2
 130:Ourwares/SerialTaskReceive.c **** 
 343              		.loc 1 130 0
 344 001e 0A20     		movs	r0, #10
 345              	.LVL29:
 346 0020 FFF7FEFF 		bl	osDelay
 347              	.LVL30:
 132:Ourwares/SerialTaskReceive.c **** 	/* Add block with circular buffer pointers for this uart/usart to list */
 348              		.loc 1 132 0
 349 0024 FFF7FEFF 		bl	vPortEnterCritical
 350              	.LVL31:
 134:Ourwares/SerialTaskReceive.c **** 	if (ptmp1  == NULL) {taskEXIT_CRITICAL();morse_trap(60);}
 351              		.loc 1 134 0
 352 0028 4C21     		movs	r1, #76
 353 002a 0120     		movs	r0, #1
 354 002c FFF7FEFF 		bl	calloc
 355              	.LVL32:
 135:Ourwares/SerialTaskReceive.c **** 	if (prbhd  == NULL) // Is this the first?
 356              		.loc 1 135 0
 357 0030 0446     		mov	r4, r0
 358 0032 20B9     		cbnz	r0, .L28
 135:Ourwares/SerialTaskReceive.c **** 	if (prbhd  == NULL) // Is this the first?
 359              		.loc 1 135 0 is_stmt 0 discriminator 1
 360 0034 FFF7FEFF 		bl	vPortExitCritical
 361              	.LVL33:
 362 0038 3C20     		movs	r0, #60
 363 003a FFF7FEFF 		bl	morse_trap
 364              	.LVL34:
 365              	.L28:
 136:Ourwares/SerialTaskReceive.c **** 	{ // Yes.  
 366              		.loc 1 136 0 is_stmt 1
 367 003e 374B     		ldr	r3, .L39
 368 0040 1B68     		ldr	r3, [r3]
 369 0042 23B9     		cbnz	r3, .L29
 138:Ourwares/SerialTaskReceive.c **** 		ptmp1->pnext = ptmp1; // Point first (and last) item on list to self
 370              		.loc 1 138 0
 371 0044 354B     		ldr	r3, .L39
 372 0046 1C60     		str	r4, [r3]
 139:Ourwares/SerialTaskReceive.c **** 	}
 373              		.loc 1 139 0
 374 0048 2460     		str	r4, [r4]
 375 004a 05E0     		b	.L30
 376              	.LVL35:
 377              	.L36:
 145:Ourwares/SerialTaskReceive.c **** 		ptmp2->pnext = ptmp1; // Last block points to added block
 378              		.loc 1 145 0
 379 004c 1346     		mov	r3, r2
 380              	.LVL36:
 381              	.L29:
 145:Ourwares/SerialTaskReceive.c **** 		ptmp2->pnext = ptmp1; // Last block points to added block
 382              		.loc 1 145 0 is_stmt 0 discriminator 1
 383 004e 1A68     		ldr	r2, [r3]
 384 0050 9342     		cmp	r3, r2
 385 0052 FBD1     		bne	.L36
 146:Ourwares/SerialTaskReceive.c **** 		ptmp1->pnext = ptmp1; // Added (and last) lock points to self
 386              		.loc 1 146 0 is_stmt 1
ARM GAS  /tmp/ccWFqRSS.s 			page 15


 387 0054 1C60     		str	r4, [r3]
 147:Ourwares/SerialTaskReceive.c **** 	}
 388              		.loc 1 147 0
 389 0056 2460     		str	r4, [r4]
 390              	.LVL37:
 391              	.L30:
 151:Ourwares/SerialTaskReceive.c **** 	     linesize = sizeof(struct CANRCVBUFPLUS);
 392              		.loc 1 151 0
 393 0058 BAF1000F 		cmp	r10, #0
 394 005c 02D0     		beq	.L31
 151:Ourwares/SerialTaskReceive.c **** 	     linesize = sizeof(struct CANRCVBUFPLUS);
 395              		.loc 1 151 0 is_stmt 0 discriminator 1
 396 005e 172D     		cmp	r5, #23
 397 0060 00D8     		bhi	.L31
 152:Ourwares/SerialTaskReceive.c **** 
 398              		.loc 1 152 0 is_stmt 1
 399 0062 1825     		movs	r5, #24
 400              	.L31:
 401              	.LVL38:
 155:Ourwares/SerialTaskReceive.c **** 	if ( pbuf == NULL) {taskEXIT_CRITICAL();morse_trap(61);}
 402              		.loc 1 155 0
 403 0064 05FB0BF7 		mul	r7, r5, fp
 404 0068 0121     		movs	r1, #1
 405 006a 3846     		mov	r0, r7
 406 006c FFF7FEFF 		bl	calloc
 407              	.LVL39:
 156:Ourwares/SerialTaskReceive.c **** 
 408              		.loc 1 156 0
 409 0070 0646     		mov	r6, r0
 410 0072 20B9     		cbnz	r0, .L32
 156:Ourwares/SerialTaskReceive.c **** 
 411              		.loc 1 156 0 is_stmt 0 discriminator 1
 412 0074 FFF7FEFF 		bl	vPortExitCritical
 413              	.LVL40:
 414 0078 3D20     		movs	r0, #61
 415 007a FFF7FEFF 		bl	morse_trap
 416              	.LVL41:
 417              	.L32:
 160:Ourwares/SerialTaskReceive.c **** 	ptmp1->linesize  = linesize;
 418              		.loc 1 160 0 is_stmt 1
 419 007e A763     		str	r7, [r4, #56]
 161:Ourwares/SerialTaskReceive.c **** 	ptmp1->numline   = numline;
 420              		.loc 1 161 0
 421 0080 A587     		strh	r5, [r4, #60]	@ movhi
 162:Ourwares/SerialTaskReceive.c **** 	ptmp1->dmaflag   = dmaflag;
 422              		.loc 1 162 0
 423 0082 84F840B0 		strb	fp, [r4, #64]
 163:Ourwares/SerialTaskReceive.c **** 	ptmp1->pnoteval  = pnoteval;
 424              		.loc 1 163 0
 425 0086 84F84190 		strb	r9, [r4, #65]
 164:Ourwares/SerialTaskReceive.c **** 	ptmp1->notebit   = notebit;
 426              		.loc 1 164 0
 427 008a 039B     		ldr	r3, [sp, #12]
 428 008c A362     		str	r3, [r4, #40]
 165:Ourwares/SerialTaskReceive.c **** 	ptmp1->phuart    = phuart;
 429              		.loc 1 165 0
 430 008e 029B     		ldr	r3, [sp, #8]
ARM GAS  /tmp/ccWFqRSS.s 			page 16


 431 0090 6362     		str	r3, [r4, #36]
 166:Ourwares/SerialTaskReceive.c **** 	ptmp1->tskhandle = xTaskGetCurrentTaskHandle();
 432              		.loc 1 166 0
 433 0092 019B     		ldr	r3, [sp, #4]
 434 0094 E361     		str	r3, [r4, #28]
 167:Ourwares/SerialTaskReceive.c **** 	ptmp1->errorct   = 0;
 435              		.loc 1 167 0
 436 0096 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 437              	.LVL42:
 438 009a 2062     		str	r0, [r4, #32]
 168:Ourwares/SerialTaskReceive.c **** 
 439              		.loc 1 168 0
 440 009c 0023     		movs	r3, #0
 441 009e A364     		str	r3, [r4, #72]
 171:Ourwares/SerialTaskReceive.c **** 	ptmp1->padd   = pbuf; // Pointer to where next line will be added
 442              		.loc 1 171 0
 443 00a0 6660     		str	r6, [r4, #4]
 172:Ourwares/SerialTaskReceive.c **** 	ptmp1->ptake  = pbuf; // Pointer to where next line will be taken
 444              		.loc 1 172 0
 445 00a2 E660     		str	r6, [r4, #12]
 173:Ourwares/SerialTaskReceive.c **** 	ptmp1->pwork  = pbuf; // Pointer where next char in active line will be added
 446              		.loc 1 173 0
 447 00a4 2661     		str	r6, [r4, #16]
 174:Ourwares/SerialTaskReceive.c **** 	ptmp1->pworkend = pbuf + linesize - 2; // End of 1st LINE buffer (allow for zero terminator)
 448              		.loc 1 174 0
 449 00a6 6661     		str	r6, [r4, #20]
 175:Ourwares/SerialTaskReceive.c **** 	ptmp1->pend = pbuf + numline*linesize; // End of line buffers + 1 line
 450              		.loc 1 175 0
 451 00a8 023D     		subs	r5, r5, #2
 452              	.LVL43:
 453 00aa 3544     		add	r5, r5, r6
 454 00ac A561     		str	r5, [r4, #24]
 176:Ourwares/SerialTaskReceive.c **** 	ptmp1->CANmode = CANmode;
 455              		.loc 1 176 0
 456 00ae 3744     		add	r7, r7, r6
 457 00b0 A760     		str	r7, [r4, #8]
 177:Ourwares/SerialTaskReceive.c **** 
 458              		.loc 1 177 0
 459 00b2 84F842A0 		strb	r10, [r4, #66]
 179:Ourwares/SerialTaskReceive.c **** 	{ // Circular DMA buffer 
 460              		.loc 1 179 0
 461 00b6 B9F1000F 		cmp	r9, #0
 462 00ba 1CD0     		beq	.L33
 181:Ourwares/SerialTaskReceive.c **** 		if ( pbuf == NULL) morse_trap(62);
 463              		.loc 1 181 0
 464 00bc 0121     		movs	r1, #1
 465 00be 4046     		mov	r0, r8
 466 00c0 FFF7FEFF 		bl	calloc
 467              	.LVL44:
 182:Ourwares/SerialTaskReceive.c **** 		ptmp1->pbegindma = pbuf;   // Pointer to beginning of DMA circular buffer
 468              		.loc 1 182 0
 469 00c4 0546     		mov	r5, r0
 470 00c6 10B9     		cbnz	r0, .L34
 182:Ourwares/SerialTaskReceive.c **** 		ptmp1->pbegindma = pbuf;   // Pointer to beginning of DMA circular buffer
 471              		.loc 1 182 0 is_stmt 0 discriminator 1
 472 00c8 3E20     		movs	r0, #62
 473              	.LVL45:
ARM GAS  /tmp/ccWFqRSS.s 			page 17


 474 00ca FFF7FEFF 		bl	morse_trap
 475              	.LVL46:
 476              	.L34:
 183:Ourwares/SerialTaskReceive.c **** 		ptmp1->penddma   = pbuf + dmasize; // Pointer to end + 1
 477              		.loc 1 183 0 is_stmt 1
 478 00ce E562     		str	r5, [r4, #44]
 184:Ourwares/SerialTaskReceive.c **** 		ptmp1->ptakedma  = pbuf;   // "Take" Pointer into DMA buffer
 479              		.loc 1 184 0
 480 00d0 05EB0803 		add	r3, r5, r8
 481 00d4 2363     		str	r3, [r4, #48]
 185:Ourwares/SerialTaskReceive.c **** 		ptmp1->dmasize   = dmasize; // Total number of chars in DMA buffer
 482              		.loc 1 185 0
 483 00d6 6563     		str	r5, [r4, #52]
 186:Ourwares/SerialTaskReceive.c **** 
 484              		.loc 1 186 0
 485 00d8 1FFA88F2 		uxth	r2, r8
 486 00dc E287     		strh	r2, [r4, #62]	@ movhi
 199:Ourwares/SerialTaskReceive.c **** 		if (halret == HAL_ERROR)
 487              		.loc 1 199 0
 488 00de 2946     		mov	r1, r5
 489 00e0 E069     		ldr	r0, [r4, #28]
 490 00e2 FFF7FEFF 		bl	HAL_UART_Receive_DMA
 491              	.LVL47:
 200:Ourwares/SerialTaskReceive.c **** 		{
 492              		.loc 1 200 0
 493 00e6 0128     		cmp	r0, #1
 494 00e8 11D1     		bne	.L35
 202:Ourwares/SerialTaskReceive.c **** 			morse_trap(64);
 495              		.loc 1 202 0
 496 00ea FFF7FEFF 		bl	vPortExitCritical
 497              	.LVL48:
 203:Ourwares/SerialTaskReceive.c **** //			return NULL;
 498              		.loc 1 203 0
 499 00ee 4020     		movs	r0, #64
 500 00f0 FFF7FEFF 		bl	morse_trap
 501              	.LVL49:
 502 00f4 0BE0     		b	.L35
 503              	.LVL50:
 504              	.L33:
 209:Ourwares/SerialTaskReceive.c **** 		if (halret == HAL_ERROR)
 505              		.loc 1 209 0
 506 00f6 0122     		movs	r2, #1
 507 00f8 3146     		mov	r1, r6
 508 00fa E069     		ldr	r0, [r4, #28]
 509 00fc FFF7FEFF 		bl	HAL_UART_Receive_IT
 510              	.LVL51:
 210:Ourwares/SerialTaskReceive.c **** 		{
 511              		.loc 1 210 0
 512 0100 0128     		cmp	r0, #1
 513 0102 04D1     		bne	.L35
 212:Ourwares/SerialTaskReceive.c **** 			morse_trap(65);
 514              		.loc 1 212 0
 515 0104 FFF7FEFF 		bl	vPortExitCritical
 516              	.LVL52:
 213:Ourwares/SerialTaskReceive.c **** //			return NULL;
 517              		.loc 1 213 0
 518 0108 4120     		movs	r0, #65
ARM GAS  /tmp/ccWFqRSS.s 			page 18


 519 010a FFF7FEFF 		bl	morse_trap
 520              	.LVL53:
 521              	.L35:
 217:Ourwares/SerialTaskReceive.c **** 	return ptmp1;	// Success return pointer to this 'BCB
 522              		.loc 1 217 0
 523 010e FFF7FEFF 		bl	vPortExitCritical
 524              	.LVL54:
 219:Ourwares/SerialTaskReceive.c **** 
 525              		.loc 1 219 0
 526 0112 2046     		mov	r0, r4
 527 0114 05B0     		add	sp, sp, #20
 528              	.LCFI8:
 529              		.cfi_def_cfa_offset 36
 530              		@ sp needed
 531 0116 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 532              	.LVL55:
 533              	.L40:
 534 011a 00BF     		.align	2
 535              	.L39:
 536 011c 00000000 		.word	.LANCHOR0
 537              		.cfi_endproc
 538              	.LFE69:
 540              		.section	.text.xSerialTaskReceiveCreate,"ax",%progbits
 541              		.align	2
 542              		.global	xSerialTaskReceiveCreate
 543              		.thumb
 544              		.thumb_func
 546              	xSerialTaskReceiveCreate:
 547              	.LFB71:
 275:Ourwares/SerialTaskReceive.c **** /*
 548              		.loc 1 275 0
 549              		.cfi_startproc
 550              		@ args = 0, pretend = 0, frame = 0
 551              		@ frame_needed = 0, uses_anonymous_args = 0
 552              	.LVL56:
 553 0000 00B5     		push	{lr}
 554              	.LCFI9:
 555              		.cfi_def_cfa_offset 4
 556              		.cfi_offset 14, -4
 557 0002 83B0     		sub	sp, sp, #12
 558              	.LCFI10:
 559              		.cfi_def_cfa_offset 16
 284:Ourwares/SerialTaskReceive.c ****         96, NULL, taskpriority, &SerialTaskReceiveHandle);
 560              		.loc 1 284 0
 561 0004 084B     		ldr	r3, .L45
 562 0006 0193     		str	r3, [sp, #4]
 563 0008 0090     		str	r0, [sp]
 564 000a 0023     		movs	r3, #0
 565 000c 6022     		movs	r2, #96
 566 000e 0749     		ldr	r1, .L45+4
 567 0010 0748     		ldr	r0, .L45+8
 568              	.LVL57:
 569 0012 FFF7FEFF 		bl	xTaskCreate
 570              	.LVL58:
 286:Ourwares/SerialTaskReceive.c **** 	return SerialTaskReceiveHandle;
 571              		.loc 1 286 0
 572 0016 0128     		cmp	r0, #1
ARM GAS  /tmp/ccWFqRSS.s 			page 19


 573 0018 02D1     		bne	.L43
 287:Ourwares/SerialTaskReceive.c **** }
 574              		.loc 1 287 0
 575 001a 034B     		ldr	r3, .L45
 576 001c 1868     		ldr	r0, [r3]
 577              	.LVL59:
 578 001e 00E0     		b	.L42
 579              	.LVL60:
 580              	.L43:
 286:Ourwares/SerialTaskReceive.c **** 	return SerialTaskReceiveHandle;
 581              		.loc 1 286 0
 582 0020 0020     		movs	r0, #0
 583              	.LVL61:
 584              	.L42:
 288:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 585              		.loc 1 288 0
 586 0022 03B0     		add	sp, sp, #12
 587              	.LCFI11:
 588              		.cfi_def_cfa_offset 4
 589              		@ sp needed
 590 0024 5DF804FB 		ldr	pc, [sp], #4
 591              	.L46:
 592              		.align	2
 593              	.L45:
 594 0028 00000000 		.word	.LANCHOR1
 595 002c 00000000 		.word	.LC0
 596 0030 00000000 		.word	StartSerialTaskReceive
 597              		.cfi_endproc
 598              	.LFE71:
 600              		.section	.text.xSerialTaskReceiveGetline,"ax",%progbits
 601              		.align	2
 602              		.global	xSerialTaskReceiveGetline
 603              		.thumb
 604              		.thumb_func
 606              	xSerialTaskReceiveGetline:
 607              	.LFB72:
 296:Ourwares/SerialTaskReceive.c **** 	char* p = NULL;
 608              		.loc 1 296 0
 609              		.cfi_startproc
 610              		@ args = 0, pretend = 0, frame = 0
 611              		@ frame_needed = 0, uses_anonymous_args = 0
 612              		@ link register save eliminated.
 613              	.LVL62:
 614 0000 0346     		mov	r3, r0
 615              	.LVL63:
 300:Ourwares/SerialTaskReceive.c **** 	p = pbcb->ptake;
 616              		.loc 1 300 0
 617 0002 0069     		ldr	r0, [r0, #16]
 618              	.LVL64:
 619 0004 DA68     		ldr	r2, [r3, #12]
 620 0006 9042     		cmp	r0, r2
 621 0008 08D0     		beq	.L49
 622              	.LVL65:
 304:Ourwares/SerialTaskReceive.c **** 	if (pbcb->ptake >= pbcb->pend) pbcb->ptake = pbcb->pbegin;
 623              		.loc 1 304 0
 624 000a 9A8F     		ldrh	r2, [r3, #60]
 625 000c 0244     		add	r2, r2, r0
ARM GAS  /tmp/ccWFqRSS.s 			page 20


 626 000e 1A61     		str	r2, [r3, #16]
 305:Ourwares/SerialTaskReceive.c **** 
 627              		.loc 1 305 0
 628 0010 9968     		ldr	r1, [r3, #8]
 629 0012 8A42     		cmp	r2, r1
 630 0014 03D3     		bcc	.L48
 305:Ourwares/SerialTaskReceive.c **** 
 631              		.loc 1 305 0 is_stmt 0 discriminator 1
 632 0016 5A68     		ldr	r2, [r3, #4]
 633 0018 1A61     		str	r2, [r3, #16]
 634 001a 7047     		bx	lr
 635              	.LVL66:
 636              	.L49:
 300:Ourwares/SerialTaskReceive.c **** 	p = pbcb->ptake;
 637              		.loc 1 300 0 is_stmt 1
 638 001c 0020     		movs	r0, #0
 639              	.LVL67:
 640              	.L48:
 308:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 641              		.loc 1 308 0
 642 001e 7047     		bx	lr
 643              		.cfi_endproc
 644              	.LFE72:
 646              		.section	.text.HAL_UART_RxCpltCallback,"ax",%progbits
 647              		.align	2
 648              		.global	HAL_UART_RxCpltCallback
 649              		.thumb
 650              		.thumb_func
 652              	HAL_UART_RxCpltCallback:
 653              	.LFB77:
 395:Ourwares/SerialTaskReceive.c **** 
 396:Ourwares/SerialTaskReceive.c **** /* #######################################################################
 397:Ourwares/SerialTaskReceive.c ****    UART interrupt callbacks
 398:Ourwares/SerialTaskReceive.c ****    ####################################################################### */
 399:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 400:Ourwares/SerialTaskReceive.c ****  * void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *phuart);
 401:Ourwares/SerialTaskReceive.c ****  * @brief	: DMA callback at the halfway point in the circular buffer
 402:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 403:Ourwares/SerialTaskReceive.c **** /* NOTE: under interrupt from callback. */
 404:Ourwares/SerialTaskReceive.c **** 
 405:Ourwares/SerialTaskReceive.c **** /* DMA Half buffer complete callback (dma only) */
 406:Ourwares/SerialTaskReceive.c **** void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *phuart)
 407:Ourwares/SerialTaskReceive.c **** {
 408:Ourwares/SerialTaskReceive.c **** 	HAL_UART_RxCpltCallback(phuart);
 409:Ourwares/SerialTaskReceive.c **** }
 410:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 411:Ourwares/SerialTaskReceive.c ****  * void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *phuart);
 412:Ourwares/SerialTaskReceive.c ****  * @brief	: DMA callback at the halfway point in the circular buffer
 413:Ourwares/SerialTaskReceive.c ****  *				: OR, char-by-char completion of sending
 414:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 415:Ourwares/SerialTaskReceive.c **** /* DMA buffer complete, => OR <= char-by-char complete */
 416:Ourwares/SerialTaskReceive.c **** 
 417:Ourwares/SerialTaskReceive.c **** void HAL_UART_RxCpltCallback(UART_HandleTypeDef *phuart)
 418:Ourwares/SerialTaskReceive.c **** {
 654              		.loc 1 418 0
 655              		.cfi_startproc
 656              		@ args = 0, pretend = 0, frame = 8
ARM GAS  /tmp/ccWFqRSS.s 			page 21


 657              		@ frame_needed = 0, uses_anonymous_args = 0
 658              	.LVL68:
 659 0000 30B5     		push	{r4, r5, lr}
 660              	.LCFI12:
 661              		.cfi_def_cfa_offset 12
 662              		.cfi_offset 4, -12
 663              		.cfi_offset 5, -8
 664              		.cfi_offset 14, -4
 665 0002 85B0     		sub	sp, sp, #20
 666              	.LCFI13:
 667              		.cfi_def_cfa_offset 32
 668 0004 0546     		mov	r5, r0
 419:Ourwares/SerialTaskReceive.c **** 	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 669              		.loc 1 419 0
 670 0006 0023     		movs	r3, #0
 671 0008 0393     		str	r3, [sp, #12]
 420:Ourwares/SerialTaskReceive.c **** 
 421:Ourwares/SerialTaskReceive.c **** 	/* Look up buffer control block, given uart handle */
 422:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* prtmp = prbhd;
 672              		.loc 1 422 0
 673 000a 154B     		ldr	r3, .L56
 674 000c 1C68     		ldr	r4, [r3]
 675              	.LVL69:
 423:Ourwares/SerialTaskReceive.c **** 	while (prtmp->phuart != phuart) prtmp++;
 676              		.loc 1 423 0
 677 000e 00E0     		b	.L51
 678              	.L52:
 679              		.loc 1 423 0 is_stmt 0 discriminator 2
 680 0010 4C34     		adds	r4, r4, #76
 681              	.LVL70:
 682              	.L51:
 683              		.loc 1 423 0 discriminator 1
 684 0012 E369     		ldr	r3, [r4, #28]
 685 0014 AB42     		cmp	r3, r5
 686 0016 FBD1     		bne	.L52
 424:Ourwares/SerialTaskReceive.c **** 
 425:Ourwares/SerialTaskReceive.c **** 	/* Note char-by-char mode from dma mode. */
 426:Ourwares/SerialTaskReceive.c **** 	if (prtmp->dmaflag == 0)
 687              		.loc 1 426 0 is_stmt 1
 688 0018 94F94130 		ldrsb	r3, [r4, #65]
 689 001c 53B9     		cbnz	r3, .L53
 427:Ourwares/SerialTaskReceive.c **** 	{ // Here char-by-char interrupt mode
 428:Ourwares/SerialTaskReceive.c **** 
 429:Ourwares/SerialTaskReceive.c **** 		// Note: char-by-char stores directly to line buffer
 430:Ourwares/SerialTaskReceive.c **** 		advanceptr(prtmp,*prtmp->pwork); 
 690              		.loc 1 430 0
 691 001e 6369     		ldr	r3, [r4, #20]
 692 0020 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 693 0022 2046     		mov	r0, r4
 694              	.LVL71:
 695 0024 FFF7FEFF 		bl	advanceptr
 696              	.LVL72:
 431:Ourwares/SerialTaskReceive.c **** 
 432:Ourwares/SerialTaskReceive.c **** 		/* Restart receiving one char. */
 433:Ourwares/SerialTaskReceive.c **** 		HAL_UART_Receive_IT(phuart, (uint8_t*)prtmp->pwork, 1); // Get next char		
 697              		.loc 1 433 0
 698 0028 0122     		movs	r2, #1
ARM GAS  /tmp/ccWFqRSS.s 			page 22


 699 002a 6169     		ldr	r1, [r4, #20]
 700 002c 2846     		mov	r0, r5
 701 002e FFF7FEFF 		bl	HAL_UART_Receive_IT
 702              	.LVL73:
 434:Ourwares/SerialTaskReceive.c **** 		return;
 703              		.loc 1 434 0
 704 0032 12E0     		b	.L50
 705              	.LVL74:
 706              	.L53:
 435:Ourwares/SerialTaskReceive.c **** 	}
 436:Ourwares/SerialTaskReceive.c **** 
 437:Ourwares/SerialTaskReceive.c **** 	/* Trigger Recieve Task to poll dma uarts */
 438:Ourwares/SerialTaskReceive.c **** 	xTaskNotifyFromISR(SerialTaskReceiveHandle, 
 707              		.loc 1 438 0
 708 0034 0B4B     		ldr	r3, .L56+4
 709 0036 1868     		ldr	r0, [r3]
 710              	.LVL75:
 711 0038 03AB     		add	r3, sp, #12
 712 003a 0093     		str	r3, [sp]
 713 003c 0023     		movs	r3, #0
 714 003e 0122     		movs	r2, #1
 715 0040 1946     		mov	r1, r3
 716 0042 FFF7FEFF 		bl	xTaskGenericNotifyFromISR
 717              	.LVL76:
 439:Ourwares/SerialTaskReceive.c **** 		0,	/* 'or' bit assigned to buffer to notification value. */
 440:Ourwares/SerialTaskReceive.c **** 		eSetBits,      /* Set 'or' option */
 441:Ourwares/SerialTaskReceive.c **** 		&xHigherPriorityTaskWoken ); 
 442:Ourwares/SerialTaskReceive.c **** 
 443:Ourwares/SerialTaskReceive.c **** 	portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 718              		.loc 1 443 0
 719 0046 039B     		ldr	r3, [sp, #12]
 720 0048 3BB1     		cbz	r3, .L50
 721              		.loc 1 443 0 is_stmt 0 discriminator 1
 722 004a 4FF08052 		mov	r2, #268435456
 723 004e 064B     		ldr	r3, .L56+8
 724 0050 1A60     		str	r2, [r3]
 725              		.syntax unified
 726              	@ 443 "Ourwares/SerialTaskReceive.c" 1
 727 0052 BFF34F8F 		dsb
 728              	@ 0 "" 2
 729              	@ 443 "Ourwares/SerialTaskReceive.c" 1
 730 0056 BFF36F8F 		isb
 731              	@ 0 "" 2
 732              		.thumb
 733              		.syntax unified
 734              	.L50:
 444:Ourwares/SerialTaskReceive.c **** 	return;
 445:Ourwares/SerialTaskReceive.c **** }
 735              		.loc 1 445 0 is_stmt 1
 736 005a 05B0     		add	sp, sp, #20
 737              	.LCFI14:
 738              		.cfi_def_cfa_offset 12
 739              		@ sp needed
 740 005c 30BD     		pop	{r4, r5, pc}
 741              	.LVL77:
 742              	.L57:
 743 005e 00BF     		.align	2
ARM GAS  /tmp/ccWFqRSS.s 			page 23


 744              	.L56:
 745 0060 00000000 		.word	.LANCHOR0
 746 0064 00000000 		.word	.LANCHOR1
 747 0068 04ED00E0 		.word	-536810236
 748              		.cfi_endproc
 749              	.LFE77:
 751              		.section	.text.HAL_UART_RxHalfCpltCallback,"ax",%progbits
 752              		.align	2
 753              		.global	HAL_UART_RxHalfCpltCallback
 754              		.thumb
 755              		.thumb_func
 757              	HAL_UART_RxHalfCpltCallback:
 758              	.LFB76:
 407:Ourwares/SerialTaskReceive.c **** 	HAL_UART_RxCpltCallback(phuart);
 759              		.loc 1 407 0
 760              		.cfi_startproc
 761              		@ args = 0, pretend = 0, frame = 0
 762              		@ frame_needed = 0, uses_anonymous_args = 0
 763              	.LVL78:
 764 0000 08B5     		push	{r3, lr}
 765              	.LCFI15:
 766              		.cfi_def_cfa_offset 8
 767              		.cfi_offset 3, -8
 768              		.cfi_offset 14, -4
 408:Ourwares/SerialTaskReceive.c **** }
 769              		.loc 1 408 0
 770 0002 FFF7FEFF 		bl	HAL_UART_RxCpltCallback
 771              	.LVL79:
 772 0006 08BD     		pop	{r3, pc}
 773              		.cfi_endproc
 774              	.LFE76:
 776              		.section	.text.HAL_UART_ErrorCallback,"ax",%progbits
 777              		.align	2
 778              		.global	HAL_UART_ErrorCallback
 779              		.thumb
 780              		.thumb_func
 782              	HAL_UART_ErrorCallback:
 783              	.LFB78:
 446:Ourwares/SerialTaskReceive.c **** /* *************************************************************************
 447:Ourwares/SerialTaskReceive.c ****  * void HAL_UART_ErrorCallback(UART_HandleTypeDef *phuart);
 448:Ourwares/SerialTaskReceive.c ****  *	@brief	: Call back from receive errror, stm32f4xx_hal_uart
 449:Ourwares/SerialTaskReceive.c ****  * *************************************************************************/
 450:Ourwares/SerialTaskReceive.c **** void HAL_UART_ErrorCallback(UART_HandleTypeDef *phuart)
 451:Ourwares/SerialTaskReceive.c **** {
 784              		.loc 1 451 0
 785              		.cfi_startproc
 786              		@ args = 0, pretend = 0, frame = 0
 787              		@ frame_needed = 0, uses_anonymous_args = 0
 788              		@ link register save eliminated.
 789              	.LVL80:
 452:Ourwares/SerialTaskReceive.c **** 	/* Look up buffer control block, given uart handle */
 453:Ourwares/SerialTaskReceive.c **** 	/* Look up buffer control block, given uart handle */
 454:Ourwares/SerialTaskReceive.c **** 	struct SERIALRCVBCB* prtmp = prbhd;
 790              		.loc 1 454 0
 791 0000 054B     		ldr	r3, .L63
 792 0002 1B68     		ldr	r3, [r3]
 793              	.LVL81:
ARM GAS  /tmp/ccWFqRSS.s 			page 24


 455:Ourwares/SerialTaskReceive.c **** 	while (prtmp->phuart != phuart) prtmp++;
 794              		.loc 1 455 0
 795 0004 00E0     		b	.L61
 796              	.L62:
 797              		.loc 1 455 0 is_stmt 0 discriminator 2
 798 0006 4C33     		adds	r3, r3, #76
 799              	.LVL82:
 800              	.L61:
 801              		.loc 1 455 0 discriminator 1
 802 0008 DA69     		ldr	r2, [r3, #28]
 803 000a 8242     		cmp	r2, r0
 804 000c FBD1     		bne	.L62
 456:Ourwares/SerialTaskReceive.c **** 	prtmp->errorct += 1;
 805              		.loc 1 456 0 is_stmt 1
 806 000e 9A6C     		ldr	r2, [r3, #72]
 807 0010 0132     		adds	r2, r2, #1
 808 0012 9A64     		str	r2, [r3, #72]
 809 0014 7047     		bx	lr
 810              	.L64:
 811 0016 00BF     		.align	2
 812              	.L63:
 813 0018 00000000 		.word	.LANCHOR0
 814              		.cfi_endproc
 815              	.LFE78:
 817              		.global	SerialTaskReceiveHandle
 818              		.section	.rodata.str1.4,"aMS",%progbits,1
 819              		.align	2
 820              	.LC0:
 821 0000 53746172 		.ascii	"StartSerialTaskReceive\000"
 821      74536572 
 821      69616C54 
 821      61736B52 
 821      65636569 
 822              		.section	.bss.prbhd,"aw",%nobits
 823              		.align	2
 824              		.set	.LANCHOR0,. + 0
 827              	prbhd:
 828 0000 00000000 		.space	4
 829              		.section	.bss.SerialTaskReceiveHandle,"aw",%nobits
 830              		.align	2
 831              		.set	.LANCHOR1,. + 0
 834              	SerialTaskReceiveHandle:
 835 0000 00000000 		.space	4
 836              		.text
 837              	.Letext0:
 838              		.file 2 "/home/deh/launchpad/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/machine/_default_t
 839              		.file 3 "/home/deh/launchpad/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/sys/_stdint.h"
 840              		.file 4 "Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM3/portmacro.h"
 841              		.file 5 "Middlewares/Third_Party/FreeRTOS/Source/include/task.h"
 842              		.file 6 "Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS/cmsis_os.h"
 843              		.file 7 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
 844              		.file 8 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 845              		.file 9 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 846              		.file 10 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_uart.h"
 847              		.file 11 "Ourwares/common_misc.h"
 848              		.file 12 "Ourwares/common_can.h"
 849              		.file 13 "Ourwares/SerialTaskReceive.h"
ARM GAS  /tmp/ccWFqRSS.s 			page 25


 850              		.file 14 "Drivers/CMSIS/Include/core_cm3.h"
 851              		.file 15 "/home/deh/launchpad/gcc-arm-none-eabi-5_4-2016q3/arm-none-eabi/include/malloc.h"
 852              		.file 16 "Ourwares/morse.h"
ARM GAS  /tmp/ccWFqRSS.s 			page 26


DEFINED SYMBOLS
                            *ABS*:00000000 SerialTaskReceive.c
     /tmp/ccWFqRSS.s:20     .text.advancebuf:00000000 $t
     /tmp/ccWFqRSS.s:24     .text.advancebuf:00000000 advancebuf
     /tmp/ccWFqRSS.s:101    .text.advancebuf:00000054 $d
     /tmp/ccWFqRSS.s:106    .text.advanceptr:00000000 $t
     /tmp/ccWFqRSS.s:110    .text.advanceptr:00000000 advanceptr
     /tmp/ccWFqRSS.s:151    .text.unloaddma:00000000 $t
     /tmp/ccWFqRSS.s:155    .text.unloaddma:00000000 unloaddma
     /tmp/ccWFqRSS.s:224    .text.StartSerialTaskReceive:00000000 $t
     /tmp/ccWFqRSS.s:229    .text.StartSerialTaskReceive:00000000 StartSerialTaskReceive
     /tmp/ccWFqRSS.s:303    .text.StartSerialTaskReceive:00000048 $d
     /tmp/ccWFqRSS.s:308    .text.xSerialTaskRxAdduart:00000000 $t
     /tmp/ccWFqRSS.s:313    .text.xSerialTaskRxAdduart:00000000 xSerialTaskRxAdduart
     /tmp/ccWFqRSS.s:536    .text.xSerialTaskRxAdduart:0000011c $d
     /tmp/ccWFqRSS.s:541    .text.xSerialTaskReceiveCreate:00000000 $t
     /tmp/ccWFqRSS.s:546    .text.xSerialTaskReceiveCreate:00000000 xSerialTaskReceiveCreate
     /tmp/ccWFqRSS.s:594    .text.xSerialTaskReceiveCreate:00000028 $d
     /tmp/ccWFqRSS.s:601    .text.xSerialTaskReceiveGetline:00000000 $t
     /tmp/ccWFqRSS.s:606    .text.xSerialTaskReceiveGetline:00000000 xSerialTaskReceiveGetline
     /tmp/ccWFqRSS.s:647    .text.HAL_UART_RxCpltCallback:00000000 $t
     /tmp/ccWFqRSS.s:652    .text.HAL_UART_RxCpltCallback:00000000 HAL_UART_RxCpltCallback
     /tmp/ccWFqRSS.s:745    .text.HAL_UART_RxCpltCallback:00000060 $d
     /tmp/ccWFqRSS.s:752    .text.HAL_UART_RxHalfCpltCallback:00000000 $t
     /tmp/ccWFqRSS.s:757    .text.HAL_UART_RxHalfCpltCallback:00000000 HAL_UART_RxHalfCpltCallback
     /tmp/ccWFqRSS.s:777    .text.HAL_UART_ErrorCallback:00000000 $t
     /tmp/ccWFqRSS.s:782    .text.HAL_UART_ErrorCallback:00000000 HAL_UART_ErrorCallback
     /tmp/ccWFqRSS.s:813    .text.HAL_UART_ErrorCallback:00000018 $d
     /tmp/ccWFqRSS.s:834    .bss.SerialTaskReceiveHandle:00000000 SerialTaskReceiveHandle
     /tmp/ccWFqRSS.s:819    .rodata.str1.4:00000000 $d
     /tmp/ccWFqRSS.s:823    .bss.prbhd:00000000 $d
     /tmp/ccWFqRSS.s:827    .bss.prbhd:00000000 prbhd
     /tmp/ccWFqRSS.s:830    .bss.SerialTaskReceiveHandle:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xTaskGenericNotifyFromISR
osDelay
xTaskNotifyWait
vPortEnterCritical
calloc
vPortExitCritical
morse_trap
xTaskGetCurrentTaskHandle
HAL_UART_Receive_DMA
HAL_UART_Receive_IT
xTaskCreate
